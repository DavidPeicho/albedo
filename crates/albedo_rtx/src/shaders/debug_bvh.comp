#version 450

#extension GL_GOOGLE_include_directive : enable

#include "structures.comp"
#include "utils/common.comp"
#include "utils/intersection_utils.comp"

/**
 * Layout 0.
 */

layout (set = 0, binding = 0, std430) buffer RayBuffer {
  RayPayload rays[];
};

layout (set = 0, binding = 1, std430) readonly buffer InstanceBuffer {
  Instance instances[];
};

layout (set = 0, binding = 2, std430) readonly buffer BVHNodeBuffer {
  BVHNode nodes[];
};

layout (set = 0, binding = 3, std430) readonly buffer IndexBuffer {
  uint indices[];
};

layout (set = 0, binding = 4, std430) readonly buffer VertexBuffer {
  Vertex vertices[];
};

layout (set = 0, binding = 5) uniform SceneSettingsBuffer {
  uint instanceCount;
  uint lightCount;
} RenderSettings;

layout(local_size_x = 8, local_size_y = 8) in;
void
main()
{
  uvec2 localSize = uvec2(8, 8);
  uvec3 dimensions = gl_NumWorkGroups * gl_WorkGroupSize;
  uvec2 numworkGroups = dimensions.xy / localSize;
  uint index =
    gl_GlobalInvocationID.z * gl_WorkGroupSize.x * numworkGroups.x * gl_WorkGroupSize.y * numworkGroups.y +
    gl_GlobalInvocationID.y * gl_WorkGroupSize.x * numworkGroups.x +
    gl_GlobalInvocationID.x;

  RayPayload ray = rays[index];

  float dist = MAX_FLOAT;

  float visited = 0.0;
  vec3 sdfColor = vec3(0.0);
  vec3 triColor = vec3(0.0);

  for (uint i = 0; i < RenderSettings.instanceCount; ++i)
  {
    Instance instance = instances[i];

    // Performs intersection in model space.
    Ray rayModel;
    rayModel.origin = transformPosition(ray.origin.xyz, instance.worldToModel);
    rayModel.dir = transformDirection(ray.dir.xyz, instance.worldToModel);
    vec3 rayInverseDir = 1.0 / rayModel.dir;

    uint nextIndex = 0;
    while (nextIndex != INVALID_UINT)
    {
      BVHNode node = nodes[instance.bvhRootIndex + nextIndex];

      if (isIntersectingAABB(rayModel.origin, rayInverseDir, node.min, node.max))
      {
        if (node.primitiveStartIndex != INVALID_UINT)
        {
          nextIndex = node.nextNodeIndex;
          continue;
        }
        nextIndex++;
      }
      else
      {
        nextIndex = node.nextNodeIndex;
      }
      visited++;
    }
  }

  ray.radiance = vec4(vec3(visited / 100.0), 1.0);
  rays[index] = ray;
}
