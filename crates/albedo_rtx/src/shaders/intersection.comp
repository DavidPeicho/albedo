#version 450

#extension GL_GOOGLE_include_directive : enable

#include "structures.comp"

#define EPSILON 0.000001
#define NEG_EPSILON -0.000001
#define EPSILON1 1.000001

#define PI_F 3.14159265359
#define TWO_PI 6.28318530718
#define TO_RAD_F (PI_F / 180.0)
#define MAX_FLOAT 3.402823466e+38

#define VEC3_UP vec3(0.0, 0.999999995, 0.0001)

#define MAX_UINT 0xFFFFFFFF
#define INVALID_UINT MAX_UINT

/**
 * Layout 0
 */

layout (set = 0, binding = 0, std430) readonly buffer InstanceBuffer {
  Instance instances[];
};

layout (set = 0, binding = 1, std430) readonly buffer BVHNodeBuffer {
  BVHNode nodes[];
};

layout (set = 0, binding = 2, std430) readonly buffer IndexBuffer {
  uint indices[];
};

layout (set = 0, binding = 3, std430) readonly buffer VertexBuffer {
  Vertex vertices[];
};

layout (set = 0, binding = 4, std430) readonly buffer LightBuffer {
  Light lights[];
};

layout (set = 0, binding = 5, std430) readonly buffer RayBuffer {
  RayPayload rays[];
};

// @todo: use writeonly when WGPU supports it.
layout (set = 0, binding = 6, std430) buffer IntersectionBuffer {
  Intersection intersections[];
};

#include "utils/intersection_utils.comp"

/* Utils */

uint
WangHash(inout uint seed)
{
  seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
  seed *= uint(9);
  seed = seed ^ (seed >> 4);
  seed *= uint(0x27d4eb2d);
  seed = seed ^ (seed >> 15);
  return seed;
}

float rand(inout uint seed)
{
  return float(WangHash(seed)) / 4294967296.0;
}

vec2
cartesianToEqui(vec3 dir)
{
  dir = dir.xzy;
  vec2 longlat = vec2(atan(dir.y, dir.x), acos(dir.z));
  longlat.x += PI_F;
  // Normalize
  return longlat / vec2(2.0 * PI_F, PI_F);
}

vec3 interpolate(vec3 v0, vec3 v1, vec3 v2, vec3 barycentric)
{
  return (
    barycentric.x * v0 +
    barycentric.y * v1 +
    barycentric.z * v2
  );
}

vec2 interpolate(vec2 v0, vec2 v1, vec2 v2, vec3 barycentric)
{
  return (
    barycentric.x * v0 +
    barycentric.y * v1 +
    barycentric.z * v2
  );
}

// Implementation of Hammersley Points on the Hemisphere
vec3
randomCosineWeightedVector(inout uint seed)
{
  // To avoid to use a second sine and a normalization, it's possible to
  // use directly the random number in [0.0; 1.0] and scale the generated
  // `x` and `z` coordinates by it to obtain a normalized vector.
  // The code below is equivalent to:
  //   x = cos(theta), y = sin(phi), z = sin(theta);
  //   normalize(x, y, z);

  float theta = rand(seed) * TWO_PI;
  float r = max(EPSILON, rand(seed));
  float rLen = sqrt(max(EPSILON, 1.0 - r));

  float z = sqrt(r); // weights the samples to tend the normal
  float x = cos(theta) * rLen; // weights to preserve normalization
  float y = sin(theta) * rLen; // weights to preserve normalization

  return vec3(x, y, z);
}

layout(local_size_x = 8, local_size_y = 8) in;
void main()
{
  uint index =
    gl_GlobalInvocationID.z * gl_WorkGroupSize.x * gl_NumWorkGroups.x * gl_WorkGroupSize.y * gl_NumWorkGroups.y +
    gl_GlobalInvocationID.y * gl_WorkGroupSize.x * gl_NumWorkGroups.x +
    gl_GlobalInvocationID.x;

  // @todo: maybe let's just make the array bigger?
  if (index < rays.length())
  {
    RayPayload rayPayload = rays[index];

    Ray ray;
    ray.origin = rayPayload.origin.xyz;
    ray.dir = rayPayload.dir.xyz;

    Intersection intersection;
    intersection.index = INVALID_UINT;
    intersection.instance = INVALID_UINT;
    intersection.emitter = INVALID_UINT;
    intersection.dist = MAX_FLOAT;
    intersection.dist = sceneHit(ray, intersection);
    intersections[index] = intersection;
  }
}
