#ifndef SAMPLING_H
#define SAMPLING_H

vec3
randomCosineWeightedVector(inout uint seed)
{
  // To avoid to use a second sine and a normalization, it's possible to
  // use directly the random number in [0.0; 1.0] and scale the generated
  // `x` and `z` coordinates by it to obtain a normalized vector.
  // The code below is equivalent to:
  //   x = cos(theta), y = sin(phi), z = sin(theta);
  //   normalize(x, y, z);

  float theta = rand(seed) * TWO_PI;
  float r = max(EPSILON, rand(seed));
  float rLen = sqrt(max(EPSILON, 1.0 - r));

  float z = sqrt(r); // weights the samples to tend the normal
  float x = cos(theta) * rLen; // weights to preserve normalization
  float y = sin(theta) * rLen; // weights to preserve normalization

  return vec3(x, y, z);
}

/**
 * Generate a random sample in an oriented hemisphere.
 *
 * @param normal The normal to the evaluated surface
 * @param tangent The tangent to the evaluated surface
 * @param bitangent The bitangent to the evaluated surface
 *
 * @return A random direction generated based on the Lambert diffuse BRDF
 */
vec3 randomSampleHemisphere(
  const in vec3 normal,
  const in vec3 tangent,
  const in vec3 bitangent,
  inout uint seed
)
{
  vec3 localDir = randomCosineWeightedVector(seed);
  return normalize(project(localDir, normal, tangent, bitangent));
}

/**
 * @override
 *
 * **Note**: This override re-compute the tangent and bitangent.
 * If you plan to call that multiple times, please use the other overload.
 */
vec3
randomSampleHemisphere(const in vec3 normal, inout uint seed)
{
  vec3 worldUp = abs(normal.z) < 0.9999 ? vec3(0, 0, 1) : vec3(1, 0, 0);
  vec3 tangent = normalize(cross(worldUp, normal));
  vec3 bitangent = cross(normal, tangent);
  return randomSampleHemisphere(normal, tangent, bitangent, seed);
}

#endif // SAMPLING_H
