#version 450

#extension GL_GOOGLE_include_directive : enable

#include "utils/math.glsl"
#include "structures.glsl"

layout (set = 0, binding = 0, std430) readonly buffer InstanceBuffer {
  Instance instances[];
};

layout (set = 0, binding = 1, std430) readonly buffer BVHNodeBuffer {
  BVHNode nodes[];
};

layout (set = 0, binding = 2, std430) readonly buffer IndexBuffer {
  uint indices[];
};

layout (set = 0, binding = 3, std430) readonly buffer VertexBuffer {
  Vertex vertices[];
};

layout (set = 0, binding = 4, std430) readonly buffer LightBuffer {
  Light lights[];
};

layout (set = 1, binding = 0, std430) readonly buffer RayBuffer {
  RayPayload rays[];
};

layout (set = 1, binding = 1, std430) readonly buffer IntersectionBuffer {
  Intersection intersections[];
};

layout(set = 1, binding = 2, rgba32f) writeonly uniform image2D gbuffer;

/* Utils */

#include "utils/intersection_utils.glsl"

layout(local_size_x = 8, local_size_y = 8) in;
void main()
{
  uint index = gl_GlobalInvocationID.y * gl_WorkGroupSize.x * gl_NumWorkGroups.x + gl_GlobalInvocationID.x;
  if (index >= rays.length()) return;

  Intersection intersection = intersections[index];

  ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
  imageStore(gbuffer, coords, vec4(vec2(coords)/vec2(gl_WorkGroupSize * gl_NumWorkGroups), 0.0, 1.0));
  // if (abs(MAX_FLOAT - intersection.dist) < EPSILON)
  // {
  //   imageStore(gbuffer, coords, vec4(0.0));
  //   return;
  // }

  // Instance instance = instances[intersection.instance];

  // // @todo: Could be refactored with the shading, that will re-compute the normal.
  // Primitive primitive = extractPrimitive(instance, intersection);
  // vec3 barycentric = barycentricCoordinates(intersection.uv);

  // vec3 normal = interpolateBarycentric(
  //   primitive.v0.normal.xyx,
  //   primitive.v1.normal.xyx,
  //   primitive.v2.normal.xyx,
  //   barycentric);

  // imageStore(gbuffer, coords, vec4(normal, intersection.dist));
}
