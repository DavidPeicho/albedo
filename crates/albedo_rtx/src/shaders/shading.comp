#version 450

#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_GOOGLE_include_directive : enable

#include "structures.comp"

#define EPSILON 0.000001
#define NEG_EPSILON -0.000001
#define EPSILON1 1.000001

#define PI_F 3.14159265359
#define TWO_PI 6.28318530718
#define TO_RAD_F (PI_F / 180.0)
#define MAX_FLOAT 3.402823466e+38

#define VEC3_UP vec3(0.0, 0.999999995, 0.0001)

#define MAX_UINT 0xFFFFFFFF
#define INVALID_UINT MAX_UINT

struct BRDFDiffuseSample
{
  float pdf;
  vec3 dir;
};

struct BRDFSpecularSample
{
  vec3 dir;
};

struct TextureInfo
{
  uint x;
  uint y;
  uint width;
  uint layerAndHeight; // 24 bits for height, 8 bits for layer index.
};

struct Material
{
  vec4  color;
  float roughnessFactor;
  float metallic;
  uint  albedoTexture;
  // @todo: for now, metal in B channel and roughness in G.
  uint  mraTexture;
};

/**
 * Layout 0.
 */

layout (set = 0, binding = 0, std430) buffer RayBuffer {
  RayPayload rays[];
};

layout (set = 0, binding = 1, std430) readonly buffer BVHNodeBuffer {
  BVHNode nodes[];
};

layout (set = 0, binding = 2, std430) readonly buffer IntersectionBuffer {
  Intersection intersections[];
};

layout (set = 0, binding = 3, std430) readonly buffer InstanceBuffer {
  Instance instances[];
};

layout (set = 0, binding = 4, std430) readonly buffer IndexBuffer {
  uint indices[];
};

layout (set = 0, binding = 5, std430) readonly buffer VertexBuffer {
  Vertex vertices[];
};

// @todo: move to uniform?
layout (set = 0, binding = 6, std430) readonly buffer LightBuffer {
  Light lights[];
};

layout (set = 0, binding = 7, std430) readonly buffer MaterialBuffer {
  Material materials[];
};

layout( set = 0, binding = 8 ) uniform texture2D Probe;

layout(set = 0, binding = 9) uniform utexture1D textureInfo;

layout(set = 0, binding = 10) uniform texture2DArray textureAtlas;

layout( set = 0, binding = 11 ) uniform sampler samplerNearest;

layout (set = 0, binding = 12) uniform GlobalUniformBuffer {
  GlobalUniforms global;
};

/* Utils */

#include "utils/intersection_utils.comp"
#include "utils/texture_utils.comp"

vec3
decodeRGBE(vec4 hdr)
{
  return hdr.rgb * exp2((hdr.a * 255.0) - 128.0);
}

vec3
sampleProbe(sampler samp, texture2D probe, vec2 uv)
{
  return decodeRGBE(texture(sampler2D(probe, samp), uv));
}

vec3
getThroughput(inout RayPayload ray)
{
  return vec3(ray.origin.w, ray.dir.w, ray.radiance.w);
}

void
setThroughput(inout RayPayload ray, vec3 throughput)
{
  ray.origin.w = throughput.x;
  ray.dir.w = throughput.y;
  ray.radiance.w = throughput.z;
}

uint
WangHash(inout uint seed)
{
  seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
  seed *= uint(9);
  seed = seed ^ (seed >> 4);
  seed *= uint(0x27d4eb2d);
  seed = seed ^ (seed >> 15);
  return seed;
}

float rand(inout uint seed)
{
  return float(WangHash(seed)) / 4294967296.0;
}

vec2
cartesianToEqui(vec3 dir)
{
  dir = dir.xzy;
  vec2 longlat = vec2(atan(dir.y, dir.x), acos(dir.z));
  longlat.x += PI_F;
  // Normalize
  return longlat / vec2(2.0 * PI_F, PI_F);
}

vec3 interpolate(vec3 v0, vec3 v1, vec3 v2, vec3 barycentric)
{
  return (
    barycentric.x * v0 +
    barycentric.y * v1 +
    barycentric.z * v2
  );
}

vec2 interpolate(vec2 v0, vec2 v1, vec2 v2, vec3 barycentric)
{
  return (
    barycentric.x * v0 +
    barycentric.y * v1 +
    barycentric.z * v2
  );
}

// Implementation of Hammersley Points on the Hemisphere
vec3
randomCosineWeightedVector(inout uint seed)
{
  // To avoid to use a second sine and a normalization, it's possible to
  // use directly the random number in [0.0; 1.0] and scale the generated
  // `x` and `z` coordinates by it to obtain a normalized vector.
  // The code below is equivalent to:
  //   x = cos(theta), y = sin(phi), z = sin(theta);
  //   normalize(x, y, z);

  float theta = rand(seed) * TWO_PI;
  float r = max(EPSILON, rand(seed));
  float rLen = sqrt(max(EPSILON, 1.0 - r));

  float z = sqrt(r); // weights the samples to tend the normal
  float x = cos(theta) * rLen; // weights to preserve normalization
  float y = sin(theta) * rLen; // weights to preserve normalization

  return vec3(x, y, z);
}

BRDFDiffuseSample
LambertBRDF(vec3 normal, inout uint randState)
{
  vec3 worldUp = abs(normal.z) < 0.9999 ? vec3(0, 0, 1) : vec3(1, 0, 0);
  vec3 tangent = normalize(cross(worldUp, normal));
  vec3 bitangent = cross(normal, tangent);
  vec3 localDir = randomCosineWeightedVector(randState);

  BRDFDiffuseSample brdf;
  brdf.dir = normalize(tangent * localDir.x + bitangent * localDir.y + localDir.z * normal);
  brdf.pdf = 0.5; // Should be PI/2 but cancels out with cosine sampling.
  return brdf;
}

BRDFSpecularSample
SpecularBRDF(vec3 dir, vec3 normal)
{
  BRDFSpecularSample brdf;
  brdf.dir = reflect(dir, normal);
  return brdf;
}

RayPayload
shade(RayPayload ray, Intersection intersection)
{
    uint randState = uint(
    gl_GlobalInvocationID.x * uint(1973)
    + gl_GlobalInvocationID.y * uint(9277)
    + uint(global.seed) * uint(26699)
  ) | uint(1);

  if (ray.terminated > 0u) {
    return ray;
  }

  vec3 throughput = getThroughput(ray);
  if (abs(MAX_FLOAT - intersection.dist) < 0.00001)
  {
    vec2 uv = cartesianToEqui(ray.dir.xyz);
    vec3 probe = sampleProbe(samplerNearest, Probe, uv);
    ray.radiance.rgb += throughput * probe;
    throughput = vec3(0.0, 0.0, 0.0);
  }
  else if (intersection.emitter != INVALID_UINT)
  {
    Light light = lights[intersection.emitter];
    ray.radiance.rgb += throughput * vec3(1.0, 0.9, 0.8) * light.intensity;
  }
  else
  {
    vec3 barycentric = vec3(1.0 - intersection.uv.x - intersection.uv.y, intersection.uv);

    uint vertexOffset = instances[intersection.instance].vertexRootIndex;
    Vertex vertex0 = getVertex(vertexOffset, intersection.index);
    Vertex vertex1 = getVertex(vertexOffset, intersection.index + 1);
    Vertex vertex2 = getVertex(vertexOffset, intersection.index + 2);

    // @todo: clean up uvs. Should UVs and normal always be packed together
    // anyway? The intersection code only need vertices.
    vec2 uv0 = vec2(vertex0.position.w, vertex0.normal.w);
    vec2 uv1 = vec2(vertex1.position.w, vertex1.normal.w);
    vec2 uv2 = vec2(vertex2.position.w, vertex2.normal.w);

    vec2 uv = interpolate(uv0, uv1, uv2, barycentric);
    vec3 normal = interpolate(vertex0.normal.xyz, vertex1.normal.xyz, vertex2.normal.xyz, barycentric);

    // 𝐿𝑟 𝛚𝑟 ≈ 𝑁 𝑓𝑟 𝛚𝑖,𝛚𝑟 𝐿𝑖 𝛚𝑖 cos𝜃𝑖⁡

    // We sample in a cosine weighted hemisphere, so basially we remove
    // the 2PI term and the multiplication by cos(𝜃) as the samples are already
    // sampled in a cosine hemisphere.
    BRDFDiffuseSample brdf = LambertBRDF(normal, randState);
    BRDFSpecularSample specBRDF = SpecularBRDF(ray.dir.xyz, normal);

    Material mat = materials[intersection.materialIndex];
    float metalness = mat.metallic;
    float roughness = mat.roughnessFactor;
    vec3 albedo = mat.color.rgb;
    if (mat.albedoTexture != MAX_UINT)
    {
      albedo *= fetchTexture(samplerNearest, mat.albedoTexture, uv).rgb;
    }
    if (mat.mraTexture != MAX_UINT)
    {
      vec4 mraFetch = fetchTexture(samplerNearest, mat.mraTexture, uv).rgba;
      roughness *= mraFetch.g;
      metalness *= mraFetch.b;
    }

    #ifdef MIS
      const float nbLights = 0.0;
      if (rand() > 1.0 / (nbLight + 1.0))
      {

      }
      else
      {
        // Ray rayEnv;
        //   rayEnv.origin = ray.origin;
        //   rayEnv.dir = ray.dir;
        // Intersection i;
        // if (sceneHit(rayEnv, i) == MAX_FLOAT)
        // {
        // }
      }
    #endif // MIS

    float r2 = roughness * roughness;
    float pdf = rand(randState) < metalness ? 1.0 : 0.0;
    vec3 dir = normalize(mix(specBRDF.dir, brdf.dir, r2));
    dir = mix(brdf.dir, dir, pdf);

    vec3 directRadiance = albedo * brdf.pdf;
    throughput *= mix(directRadiance, vec3(1.0), pdf);

    ray.origin.xyz += intersection.dist * ray.dir.xyz + normal * EPSILON;
    ray.dir.xyz = dir;
  }

  // {
  //   // Russian roulette.
  //   float p = max(throughput.r, max(throughput.g, throughput.b));
  //   if (rand(randState) > p) {
  //     ray.terminated = 1u;
  //   } else {
  //     throughput *= 1.0 / p;
  //   }
  // }

  setThroughput(ray, throughput);
  return ray;
}

layout(local_size_x = 8, local_size_y = 8) in;
void
main()
{
  uint index =
    gl_GlobalInvocationID.z * gl_WorkGroupSize.x * gl_NumWorkGroups.x * gl_WorkGroupSize.y * gl_NumWorkGroups.y +
    gl_GlobalInvocationID.y * gl_WorkGroupSize.x * gl_NumWorkGroups.x +
    gl_GlobalInvocationID.x;

  // @todo: maybe let's just make the array bigger?
  if (index < rays.length())
  {
    RayPayload ray = rays[index];
    Intersection intersection = intersections[index];
    // Modified ray is written back to SSBO.
    rays[index] = shade(ray, intersection);
  }
}
