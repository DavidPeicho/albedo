#version 450

#extension GL_GOOGLE_include_directive : enable

#include "structures.comp"

/**
 * Layout 0
 */

// @todo: use writeonly when WGPU supports it.
layout (set = 0, binding = 0, std430) buffer RayBuffer {
  RayPayload rays[];
};

layout (set = 0, binding = 1) readonly uniform CameraUniformsBuffer {
  vec3 origin;
  float vFOV;
  vec3 up;
  float padding_0;
  vec3 right;
  float padding_1;
} CameraUniforms;

RayPayload
generateRay(uvec3 coords, uvec2 dimensions)
{
  RayPayload ray;

  float half_w = float(dimensions.x) * 0.5;
  float half_h = float(dimensions.y) * 0.5;

  vec3 clip = vec3(
    coords.x - half_w,
    coords.y - half_h,
    half_h / tan(CameraUniforms.vFOV * 0.5)
  );

  // TODO: pack direction directly?
  vec3 dir = normalize(cross(CameraUniforms.up, CameraUniforms.right));

  // `throughput` is packed in `origin.w`, `dir.w`, and `radiance.w`.
  ray.origin = vec4(CameraUniforms.origin, 1.0);
  ray.dir = vec4(
    normalize(clip.x * CameraUniforms.right + clip.y * CameraUniforms.up + clip.z * dir),
    1.0 // throughput component
  );
  ray.radiance = vec4(vec3(0.0), 1.0);

  return ray;
}

// @todo: not hardcoding that means generating the shader at runtime
layout(local_size_x = 8, local_size_y = 8) in;
void main()
{
  uvec2 localSize = uvec2(8, 8);
  uvec2 dimensions = (gl_NumWorkGroups * gl_WorkGroupSize).xy;
  uvec2 numworkGroups =  dimensions / localSize;
  uint index =
    gl_GlobalInvocationID.z * gl_WorkGroupSize.x * numworkGroups.x * gl_WorkGroupSize.y * numworkGroups.y +
    gl_GlobalInvocationID.y * gl_WorkGroupSize.x * numworkGroups.x +
    gl_GlobalInvocationID.x;

  rays[index] = generateRay(gl_GlobalInvocationID, dimensions);
}
