#version 450

#extension GL_GOOGLE_include_directive : enable

#include "structures.comp"

// @todo: not hardcoding that means generating the shader at runtime
layout(local_size_x = 8, local_size_y = 8) in;

/**
 * Layout 0
 */

layout (set = 0, binding = 0, std430) writeonly buffer RayBuffer {
  Ray rays[];
};

layout (set = 0, binding = 1) readonly uniform CameraUniformsBuffer {
  vec3 origin;
  float vFOV;
  vec3 up;
  float padding_0;
  vec3 right;
  float padding_1;
} CameraUniforms;

/* Utils */

uint
WangHash(inout uint seed)
{
  seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
  seed *= uint(9);
  seed = seed ^ (seed >> 4);
  seed *= uint(0x27d4eb2d);
  seed = seed ^ (seed >> 15);
  return seed;
}

float rand(inout uint seed)
{
  return float(WangHash(seed)) / 4294967296.0;
}

Ray
generateRay(uvec3 coords, uvec3 dimensions)
{
  Ray ray;

  float half_w = float(dimensions.x) * 0.5;
  float half_h = float(dimensions.y) * 0.5;

  vec3 clip = vec3(
    coords.x - half_w,
    coords.y - half_h,
    half_h / tan(CameraUniforms.vFOV * 0.5)
  );

  ray.origin = CameraUniforms.origin;

  // TODO: pack direction directly?
  vec3 dir = normalize(cross(CameraUniforms.up, CameraUniforms.right));

  ray.dir = clip.x * CameraUniforms.right + clip.y * CameraUniforms.up + clip.z * dir;
  ray.dir = normalize(ray.dir);

  return ray;
}

void main()
{
  // uvec3 dimensions = uvec3(gl_NumWorkGroups) * uvec3(gl_WorkGroupSize);
  // @todo: unharcode
  uvec3 dimensions = uvec3(640, 480, 1);
  Ray ray = generateRay(gl_GlobalInvocationID, dimensions);
  uint index = gl_GlobalInvocationID.y * dimensions.x + gl_GlobalInvocationID.x;
  rays[index] = ray;
}
